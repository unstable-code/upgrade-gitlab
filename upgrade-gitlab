#!/usr/bin/env bash

BACKUP_DIR=
DISCORD_URL=${DISCORD_URL:-}
GITLAB_EDITION=
PULL_PID=

skip_latest=0
target_version_tag=
auto_restart_enabled=no
_in_stacktrace=0
edition_flag=
auto_yes=0
_interrupted=0
_trap_active=0
_pull_pid=
_pull_interrupted=0

# shellcheck disable=SC2329
_handle_signal() {
    if [ "$_trap_active" -eq 1 ]; then
        _interrupted=1
        echo -e "\nSignal received. Will exit at next safe point..." >&2
        return
    fi
    if [ -n "$PULL_PID" ]; then
        kill "$PULL_PID" 2>/dev/null
    fi
    exit 130
}
trap _handle_signal SIGINT SIGTERM SIGTSTP SIGHUP

# shellcheck disable=SC2329
_pull_signal_handler() {
    if [ -n "$_pull_pid" ]; then
        kill "$_pull_pid" 2>/dev/null
        wait "$_pull_pid" 2>/dev/null
    fi
    _pull_interrupted=1
}

enter_critical() {
    _trap_active=1
    echo "Entering critical section: only SIGQUIT (Ctrl+\\) or SIGKILL can interrupt." >&2
}
exit_critical() {
    _trap_active=0
    echo "Exiting critical section." >&2
    if [ "$_interrupted" -eq 1 ]; then
        echo "Interrupted. Exiting at safe point." >&2
        exit 130
    fi
}

pull_with_retry() {
    local image=$1
    trap _pull_signal_handler SIGINT SIGTERM SIGTSTP SIGHUP

    while true; do
        _pull_interrupted=0
        docker pull "$image" &
        _pull_pid=$!
        wait "$_pull_pid"
        local rc=$?
        _pull_pid=

        if [ $rc -eq 0 ]; then
            break
        elif [ "$_pull_interrupted" -eq 1 ]; then
            echo -e "\nPull interrupted. Restarting download... (Ctrl+\\\\ to force quit)"
            continue
        else
            echo "Error: docker pull failed with exit code $rc" >&2
            trap _handle_signal SIGINT SIGTERM SIGTSTP SIGHUP
            return $rc
        fi
    done

    trap _handle_signal SIGINT SIGTERM SIGTSTP SIGHUP
}

if [ "$1" == "--help" ] || [ "$1" == "help" ]; then
    echo "Usage: $0 [-y] [--edition=ce|ee] [--target-url=http] [--discord-url=http] [--version=0.0.0] [--skip-latest]"

    echo -e '\n\e[0;1mOPTIONS\e[m'
    echo -e "-y\t\t\tAuto-confirm prompts for unattended/cron usage. Aborts on safety warnings and if upgrade path >= 3 steps."
    echo -e "--help\t\t\tShow this help."
    echo -e "--edition=ce|ee\t\tForce GitLab edition (ce or ee). Auto-detected if omitted."
    echo -e "--version=0.0.0\t\tUse provided tag instead of latest tag. Partial versions (e.g. 18) are resolved automatically."
    echo -e "--skip-latest\t\tTarget the second-latest version (N-1 strategy). (alias: --n-1)"
    echo -e "--target-url=http\tPerform a simple connection test for your GitLab server."
    echo -e "--discord-url=http\tNotify via Discord webhook."

    echo -e '\n\e[0;1mENV VALUES\e[m'
    echo -e "TARGET_URL=http\t\tSame as --target-url flag."
    echo -e "DISCORD_URL=http\tSame as --discord-url flag."
    exit 0
else
    params=("${@}")
    for i in "${!params[@]}"; do
        if [[ "${params[$i]}" == "-"* ]]; then
            temp=$(echo "${params[$i]}" | awk -F '=' '{ print $2 }')

            if [ "${params[$i]}" == "-y" ] || [ "${params[$i]}" == "--yes" ]; then
                auto_yes=1
            elif [ "${params[$i]}" == "--skip-latest" ] || [ "${params[$i]}" == "--n-1" ]; then
                skip_latest=1
            elif [[ "${params[$i]}" == "--edition"* ]]; then
                if [ "$temp" != "ce" ] && [ "$temp" != "ee" ]; then
                    echo "Error: --edition must be 'ce' or 'ee'" >&2
                    exit 1
                fi
                edition_flag=$temp
            elif [[ "${params[$i]}" == "--version"* ]]; then
                if [ $skip_latest -eq 1 ]; then
                    echo "Error: --version and --skip-latest cannot be used together." >&2
                    exit 1
                fi
                if [ -n "$target_version_tag" ]; then
                    echo "Warning: Overriding target_version_tag from $target_version_tag to $temp"
                fi
                # Edition suffix will be applied after GITLAB_EDITION is determined
                target_version_tag=$temp
            elif [[ "${params[$i]}" == "--target-url"* ]]; then
                if [ -n "$TARGET_URL" ]; then
                    echo "Warning: Overriding TARGET_URL from $TARGET_URL to $temp"
                fi
                TARGET_URL=$temp
            elif [[ "${params[$i]}" == "--discord-url"* ]]; then
                if [ -n "$DISCORD_URL" ]; then
                    echo "Warning: Overriding DISCORD_URL from $DISCORD_URL to $temp"
                fi
                DISCORD_URL=$temp
            fi
        fi
    done
fi

# --------------------------
# ëŒ€í™”í˜• ëª¨ë“œ TTY ê²€ì¦
# --------------------------
if [ $auto_yes -eq 0 ] && [ ! -t 0 ]; then
    echo "Error: stdin is not a terminal. Use -y/--yes for non-interactive mode." >&2
    exit 1
fi

# --------------------------
# í•„ìˆ˜ ìœ í‹¸ë¦¬í‹° ì‚¬ì „ ê²€ì¦
# --------------------------
for util in curl jq; do
    if ! which "$util" &> /dev/null; then
        echo "Error: Required utility '$util' is not installed. $(uname -a)" >&2
        if [ -d /usr/syno ]; then
            echo "Hint: On Synology DSM, install '$util' via Entware or opkg." >&2
        fi
        exit 1
    fi
done

if ! echo -e "1.10.0\n1.2.0" | sort -V &> /dev/null; then
    echo "Error: 'sort' does not support version sorting (-V). GNU coreutils is required." >&2
    exit 1
fi

if [ "${BASH_VERSION%%.*}" -lt 4 ] 2>/dev/null; then
    echo "Error: Bash 4.0+ is required (current: $BASH_VERSION)." >&2
    exit 1
fi

if ! which docker &> /dev/null; then
    echo "Docker is not installed on this system. $(uname -a)" >&2
    if [ -d /usr/syno ]; then
        echo 'Please install Docker (Obsolete) or ContainerManager before running this script.' >&2
        echo -e '\nRef:\n\thttps://www.synology.com/dsm/feature/container-manager' >&2
    else
        echo 'Please install DockerEngine or DockerDesktop before running this script.' >&2
        echo -e '\nRef:\n\thttps://docs.docker.com/engine/install\n\thttps://docs.docker.com/desktop' >&2
    fi
    exit 1
fi

if ! id | grep docker &> /dev/null && [ $UID -ne 0 ]; then
    echo "The $USER user does not have enough docker.sock permissions." >&2
    exit 1
fi

# --------------------------
# ğŸ” gitlab/gitlab-ce ë˜ëŠ” gitlab/gitlab-ee ì»¨í…Œì´ë„ˆ ìë™ ê°ì§€
# --------------------------
CONTAINER_CANDIDATES=$(docker ps -a --format "{{.Image}}\t{{.Names}}" | grep "^gitlab/gitlab-\(ce\|ee\)" | awk '{print $2}')

# ì´ë¦„ìœ¼ë¡œ ëª» ì°¾ìœ¼ë©´ ì´ë¯¸ì§€ ID â†’ RepoTags ì—­ì¡°íšŒë¡œ ì¬ì‹œë„
if [ -z "$CONTAINER_CANDIDATES" ]; then
    while IFS=$'\t' read -r img name; do
        repo_tags=$(docker image inspect "$img" --format='{{range .RepoTags}}{{.}} {{end}}' 2>/dev/null)
        if echo "$repo_tags" | grep -q "gitlab/gitlab-\(ce\|ee\)"; then
            CONTAINER_CANDIDATES="${CONTAINER_CANDIDATES:+$CONTAINER_CANDIDATES$'\n'}$name"
        fi
    done < <(docker ps -a --format "{{.Image}}\t{{.Names}}")
fi

CONTAINER_COUNT=$(echo "$CONTAINER_CANDIDATES" | grep -c .)

if [ "$CONTAINER_COUNT" -eq 0 ]; then
    echo 'Error: No container using gitlab/gitlab-ce or gitlab/gitlab-ee image found.' >&2
    exit 1
elif [ "$CONTAINER_COUNT" -gt 1 ]; then
    echo 'Error: Multiple GitLab containers found:' >&2
    echo "  - ${CONTAINER_CANDIDATES//$'\n'/$'\n'  - }" >&2
    echo 'Please keep only one container running or specify which one to upgrade.' >&2
    exit 1
fi

CONTAINER_NAME=$CONTAINER_CANDIDATES
echo "Detected gitlab container: $CONTAINER_NAME"

# --------------------------
# ì—ë””ì…˜ ìë™ ê°ì§€ (CE/EE)
# --------------------------
CONFIG_IMAGE=$(docker inspect "$CONTAINER_NAME" --format='{{.Config.Image}}')
if ! echo "$CONFIG_IMAGE" | grep -q "^gitlab/gitlab-"; then
    CONFIG_IMAGE=$(docker image inspect "$CONFIG_IMAGE" --format='{{range .RepoTags}}{{.}} {{end}}' 2>/dev/null \
        | grep -oE "gitlab/gitlab-(ce|ee)[^ ]*" | head -1)
    if [ -z "$CONFIG_IMAGE" ]; then
        echo "Error: Cannot determine GitLab edition from container image." >&2
        echo "Hint: Try running 'docker tag <IMAGE_ID> gitlab/gitlab-ce:<VERSION>' to restore the image tag." >&2
        exit 1
    fi
fi
DETECTED_EDITION=$(echo "$CONFIG_IMAGE" | sed 's|gitlab/gitlab-||;s|:.*||')

if [ -n "$edition_flag" ]; then
    if [ "$DETECTED_EDITION" == "ee" ] && [ "$edition_flag" == "ce" ]; then
        echo "Error: Downgrading from EE to CE is not supported due to data loss risk." >&2
        exit 1
    fi
    if [ "$DETECTED_EDITION" != "$edition_flag" ]; then
        echo "Edition switch requested: $DETECTED_EDITION -> $edition_flag"
    fi
    GITLAB_EDITION=$edition_flag
else
    GITLAB_EDITION=$DETECTED_EDITION
    if [ "$GITLAB_EDITION" == "ce" ] && [ $auto_yes -eq 0 ]; then
        echo -en "Detected edition: CE. Would you like to switch to EE? (y/N) > "
        read -r switch_ee < /dev/tty
        if [ "$switch_ee" == "y" ] || [ "$switch_ee" == "Y" ]; then
            GITLAB_EDITION="ee"
            echo "Edition switch requested: ce -> ee"
        fi
    fi
fi

echo "Using GitLab edition: $GITLAB_EDITION"

GITLAB_IMAGE="gitlab/gitlab-${GITLAB_EDITION}"
TAG_SUFFIX="-${GITLAB_EDITION}.0"

# --version í”Œë˜ê·¸ì˜ ì—ë””ì…˜ suffix ì ìš© (GITLAB_EDITION í™•ì • í›„)
_partial_version=0
if [ -n "$target_version_tag" ]; then
    # partial version ê°ì§€ (x ë˜ëŠ” x.y í˜•ì‹)
    if [[ "$target_version_tag" =~ ^[0-9]+$ ]] || [[ "$target_version_tag" =~ ^[0-9]+\.[0-9]+$ ]]; then
        _partial_version=1
        echo "Partial version provided: $target_version_tag (will resolve after fetching tags)"
    else
        if [ "$(echo "$target_version_tag" | grep -c "\-${GITLAB_EDITION}")" -ne 1 ]; then
            target_version_tag="${target_version_tag}${TAG_SUFFIX}"
        fi

        if curl -sf "https://hub.docker.com/v2/repositories/${GITLAB_IMAGE}/tags/$target_version_tag" &> /dev/null; then
            echo "Using $target_version_tag instead of latest"
        else
            echo "Error: No such $target_version_tag tag in Docker Hub. Using alternative tag: latest" >&2
            target_version_tag=
        fi
    fi
fi

# --------------------------
# 1ï¸âƒ£ ë³¼ë¥¨ ë§ˆìš´íŠ¸ ì¶”ì¶œ
# --------------------------
VOLUMES=$(docker inspect "$CONTAINER_NAME" --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' \
    | tr ' ' '\n' \
    | sed '/^$/d' \
    | awk '{printf "-v %s ", $0}' \
    | sed 's/ $//')

# --------------------------
# 2ï¸âƒ£ í¬íŠ¸ ë§¤í•‘ ì¶”ì¶œ
# --------------------------
PORTS=$(docker inspect "$CONTAINER_NAME" --format='{{range $p, $conf := .HostConfig.PortBindings}}{{$p}}:{{(index $conf 0).HostPort}} {{end}}' \
    | tr ' ' '\n' \
    | sed '/^$/d' \
    | sed 's/\/tcp//g' \
    | awk -F: '{printf "-p %s:%s ", $2, $1}')

send_discord_webhook() {
    if [ -z "$DISCORD_URL" ] || [ $# -ne 3 ]; then
        return 1
    fi

    format_title=
    hex_color=
    if [ "$1" == "ERR" ]; then
        hex_color=15158332 #ë¹¨ê°•
        format_title="ğŸ›‘ $2"
    elif [ "$1" == "WARN" ]; then
        hex_color=15904252 #ì£¼í™©
        format_title="âš ï¸ $2"
    elif [ "$1" == "NOTE" ]; then
        hex_color=3447003  #íŒŒë‘
        format_title="ğŸ”” $2"
    elif [ "$1" == "INFO" ]; then
        format_title="â„¹ï¸ $2"
        hex_color=3066993  #ì´ˆë¡
    else
        return 1
    fi

    JSON_PAYLOAD=$(jq -n \
        --arg title "$format_title" \
        --arg description "$3" \
        --argjson color "$hex_color" \
        '{
            "embeds": [{
                "title": $title,
                "color": $color,
                "fields": [
                    {"name": "Description", "value": $description, "inline": false}
                ],
                "footer": {"text": "GitLab upgrade helper"},
                "timestamp": (now | todate)
            }]
        }'
    )
    curl -s -H "Content-Type: application/json" \
        -X POST \
        -d "$JSON_PAYLOAD" \
        "$DISCORD_URL" &> /dev/null
}

_check_volume_space() {
    local volume_path=$1 label=$2
    local used_kb avail_kb required_kb

    used_kb=$(du -sk "$volume_path" 2>/dev/null | awk '{print $1}')
    avail_kb=$(df -k "$volume_path" 2>/dev/null | tail -1 | awk '{print $4}')

    if [ -z "$used_kb" ] || [ -z "$avail_kb" ]; then
        echo "  Warning: Could not determine $label volume space. Skipping." >&2
        return 0
    fi

    required_kb=$(( used_kb * 3 / 2 ))
    local used_gb=$(( used_kb / 1048576 ))
    local avail_gb=$(( avail_kb / 1048576 ))
    local required_gb=$(( required_kb / 1048576 ))

    echo "  $label volume: data=${used_gb}GB, available=${avail_gb}GB, recommended=${required_gb}GB (1.5x)"

    if [ "$avail_kb" -lt "$required_kb" ]; then
        echo "  WARNING: Insufficient $label disk space! ($volume_path)" >&2
        return 1
    fi
    return 0
}

check_disk_space() {
    local data_volume
    data_volume=$(docker inspect "$CONTAINER_NAME" \
        --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' \
        | tr ' ' '\n' | grep '/var/opt/gitlab' | awk -F: '{print $1}')

    local backup_path
    backup_path=$(docker exec "$CONTAINER_NAME" grep "'backup_path'" /etc/gitlab/gitlab.rb 2>/dev/null \
        | awk -F"=" '{ print $2 }' | sed 's/"//g' | sed 's/^ //')

    local backup_volume=""
    if [ -n "$backup_path" ]; then
        backup_volume=$(docker inspect "$CONTAINER_NAME" \
            --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' \
            | tr ' ' '\n' | while read -r mount; do
                local dest="${mount#*:}"
                local src="${mount%%:*}"
                if [[ "$backup_path" == "$dest"* ]]; then
                    echo "${src}${backup_path#"$dest"}"
                    break
                fi
            done)
    fi

    if [ -z "$data_volume" ]; then
        echo "Warning: Could not detect GitLab data volume path. Skipping disk space check." >&2
        return 0
    fi

    local insufficient=0

    _check_volume_space "$data_volume" "Data" || insufficient=1

    if [ -n "$backup_volume" ]; then
        local data_dev backup_dev
        data_dev=$(df "$data_volume" 2>/dev/null | tail -1 | awk '{print $1}')
        backup_dev=$(df "$backup_volume" 2>/dev/null | tail -1 | awk '{print $1}')
        if [ "$data_dev" != "$backup_dev" ]; then
            _check_volume_space "$backup_volume" "Backup" || insufficient=1
        else
            echo "  Note: Backup path is on the same device as data volume."
        fi
    fi

    if [ "$insufficient" -eq 1 ]; then
        send_discord_webhook "WARN" "Low disk space detected" "Review disk space before upgrading"
        if [ $auto_yes -eq 1 ]; then
            echo "Aborted due to insufficient disk space (-y mode)." >&2
            exit 1
        fi
        echo -n "Continue anyway? (y/N) > "
        read -r disk_confirm < /dev/tty
        if [ "$disk_confirm" != "y" ] && [ "$disk_confirm" != "Y" ]; then
            echo "Aborted due to insufficient disk space." >&2
            exit 1
        fi
    fi
}

check_secrets_integrity() {
    local phase=$1
    echo "Verifying secrets integrity ($phase)..."
    # gitlab:doctor:secrets ëŠ” GitLab 13.1 ì´ìƒì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥
    local output
    output=$(run_with_bouncing_bar "Secrets Check" docker exec "$CONTAINER_NAME" gitlab-rake gitlab:doctor:secrets 2>&1)
    local rc=$?
    if [ $rc -ne 0 ]; then
        if echo "$output" | grep -q "Don't know how to build task"; then
            echo "Skipping secrets integrity check ($phase): task not available in this version" >&2
            return 0
        fi
        echo "Warning: Secrets integrity check failed ($phase). Please review manually." >&2
        send_discord_webhook "WARN" "Secrets check failed ($phase)" "Run gitlab-rake gitlab:doctor:secrets"
        return 1
    fi
    return 0
}

wait_for_background_migrations() {
    # batched_background_migrations í…Œì´ë¸”ì€ GitLab 13.10 ì´ìƒì—ì„œë§Œ ì¡´ì¬
    local table_exists
    table_exists=$(docker exec "$CONTAINER_NAME" gitlab-psql -tAc \
        "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'batched_background_migrations');" \
        2>/dev/null | tr -d '[:space:]')
    if [ "$table_exists" != "t" ]; then
        echo "Skipping background migration check: table not available in this version"
        return 0
    fi

    echo "Waiting for background migrations to complete..."
    local spinner='/-\|'
    local spin_idx=0
    local prev_lines=0

    while true; do
        # ê°œë³„ ë§ˆì´ê·¸ë ˆì´ì…˜: name|completed_jobs|total_jobs
        PROGRESS=$(docker exec "$CONTAINER_NAME" gitlab-psql -tAc "
            SELECT m.job_class_name || '|' ||
                (SELECT COUNT(*) FROM batched_background_migration_jobs j
                 WHERE j.batched_background_migration_id = m.id AND j.status = 3) || '|' ||
                (SELECT COUNT(*) FROM batched_background_migration_jobs j
                 WHERE j.batched_background_migration_id = m.id)
            FROM batched_background_migrations m
            WHERE m.status NOT IN (3, 6)
            ORDER BY m.id;
        " 2>/dev/null)

        # ì´ì „ ì¶œë ¥ ì§€ìš°ê¸°
        if [ "$prev_lines" -gt 1 ]; then
            printf '\033[%dA' "$((prev_lines - 1))"
        fi
        if [ "$prev_lines" -gt 0 ]; then
            printf '\r\033[J'
        fi

        if [ -z "$PROGRESS" ]; then
            REMAINING=$(docker exec "$CONTAINER_NAME" gitlab-psql -tAc \
                "SELECT COUNT(*) FROM batched_background_migrations WHERE status NOT IN (3, 6);" \
                2>/dev/null | tr -d '[:space:]')
            if [[ "$REMAINING" =~ ^[0-9]+$ ]] && [ "$REMAINING" -eq 0 ]; then
                echo "Background migrations: all completed"
                break
            fi
            printf "Background migrations: waiting for response... %s" "${spinner:spin_idx++%${#spinner}:1}"
            prev_lines=1
            for ((s=0; s<5; s++)); do
                sleep 1
                printf '\r'"Background migrations: waiting for response... %s" "${spinner:spin_idx++%${#spinner}:1}"
            done
            continue
        fi

        local active_count all_done=true interval
        active_count=$(echo "$PROGRESS" | wc -l)
        printf "Background migrations: [%d active] %s" "$active_count" "${spinner:spin_idx++%${#spinner}:1}"
        prev_lines=1

        while IFS='|' read -r name completed total; do
            if [ -z "$total" ] || [ "$total" -eq 0 ] 2>/dev/null; then
                printf "\n  %s: Pending" "$name"
                all_done=false
            else
                local pct=$((completed * 100 / total))
                printf "\n  %s: %d%% (%d/%d)" "$name" "$pct" "$completed" "$total"
                if [ "$completed" -ne "$total" ]; then
                    all_done=false
                fi
            fi
            prev_lines=$((prev_lines + 1))
        done <<< "$PROGRESS"

        if [ "$all_done" = true ]; then interval=5; else interval=15; fi
        for ((s=0; s<interval; s++)); do
            sleep 1
            if [ "$prev_lines" -gt 1 ]; then
                printf '\033[%dA' "$((prev_lines - 1))"
            fi
            printf '\r'"Background migrations: [%d active] %s" "$active_count" "${spinner:spin_idx++%${#spinner}:1}"
            if [ "$prev_lines" -gt 1 ]; then
                printf '\033[%dB' "$((prev_lines - 1))"
            fi
        done
    done
}

check_migration_status() {
    local migrate_output
    migrate_output=$(run_with_bouncing_bar "Migration Status" docker exec "$CONTAINER_NAME" gitlab-rake db:migrate:status 2>/dev/null)
    local down_count
    down_count=$(echo "$migrate_output" | grep -c "^\s*down")
    if [ "$down_count" -gt 0 ]; then
        echo "Warning: $down_count migration(s) in 'down' state detected" >&2
        echo "$migrate_output" | grep "^\s*down" >&2
        send_discord_webhook "WARN" "Migration status issue" "$down_count migration(s) in down state"
    fi
}

wait_for_http_ready() {
    local label=$1
    echo "waiting until $label server boots..."
    # shellcheck disable=SC2329
    _http_ready_check() {
        [ "$(curl -sf -o /dev/null "$TARGET_URL/users/sign_in" -w "%{http_code}" 2>/dev/null)" = '200' ]
    }
    poll_with_bouncing_bar "HTTP Ready" _http_ready_check
    unset -f _http_ready_check
    echo 'done'
}

wait_for_healthy() {
    local label=$1
    echo "waiting until $label container is ready..."
    # shellcheck disable=SC2329
    _healthy_check() {
        [ "$(docker inspect --format='{{.State.Health.Status}}' "$CONTAINER_NAME" | grep -v unhealthy | grep -c healthy)" -eq 1 ]
    }
    poll_with_bouncing_bar "Health Check" _healthy_check
    unset -f _healthy_check
    echo 'done'
}

check_gitlab_server_healthy() {
    local skip_reconfigure=${1:-0}
    if docker exec "$CONTAINER_NAME" gitlab-ctl status; then
        enter_critical
        if [ "$skip_reconfigure" -eq 0 ]; then
            run_with_bouncing_bar "Reconfigure" docker exec "$CONTAINER_NAME" gitlab-ctl reconfigure
        else
            run_with_bouncing_bar "Restart" docker exec "$CONTAINER_NAME" gitlab-ctl restart
        fi
        run_with_bouncing_bar "PG Upgrade" docker exec "$CONTAINER_NAME" gitlab-ctl pg-upgrade
        run_with_bouncing_bar "DB Migrate" docker exec "$CONTAINER_NAME" gitlab-rake db:migrate
        exit_critical
        run_with_bouncing_bar "Status" docker exec "$CONTAINER_NAME" gitlab-ctl status || print_stacktrace_errors
    else
        print_stacktrace_errors
    fi
}

print_stacktrace_errors() {
    if [ $_in_stacktrace -eq 1 ]; then
        return 0
    fi
    if [ "$(docker inspect --format='{{.State.ExitCode}}' "$CONTAINER_NAME")" -ne 0 ]; then
        _in_stacktrace=1
        echo -e "\nError: gitlab container died with the following status code: $(docker inspect --format='{{.State.ExitCode}}' "$CONTAINER_NAME")" >&2

        docker logs --tail 200 "$CONTAINER_NAME" >&2
        send_discord_webhook "ERR" "FATAL ERROR occurred!" "See: https://docs.gitlab.com/administration/backup_restore"
        echo -e '\e[1;5;37;41mFATAL ERROR: MANUAL INTERVENTION IS REQUIRED\e[0m' >&2
        # shellcheck disable=SC2016
        echo 'upgrade-gitlab script does not recover this issue. Please restore previous backup with `gitlab-rake gitlab:backup:restore`' >&2
        echo 'For more information, please visit: https://docs.gitlab.com/administration/backup_restore' >&2
        echo 'Troubleshooting guide: https://gitlab.com/unstable-code/upgrade-gitlab/-/wikis/Troubleshooting' >&2
        if [ -z "$BACKUP_DIR" ]; then
            BACKUP_DIR=$(docker exec "$CONTAINER_NAME" grep "'backup_path'" /etc/gitlab/gitlab.rb 2>/dev/null | awk -F"=" '{ print $2 }' | sed 's/\"//g' | sed 's/^ //')
        fi
        echo "backup_path: $BACKUP_DIR" >&2
        exit 1
    fi
}

if ! docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
    docker start "$CONTAINER_NAME" &> /dev/null
    wait_for_healthy "GitLab server"
fi

CURRENT_VERSION=$(docker exec "$CONTAINER_NAME" dpkg -l | grep gitlab | awk '{ print $3 }')
if [ -z "$CURRENT_VERSION" ]; then
    exit 1
fi

start_time=$SECONDS

draw_progress() {
    local current=$1
    local total=$2
    local prefix=$3
    local item_name=$4
    local cols=${COLUMNS:-$(tput cols 2>/dev/null || stty size 2>/dev/null | awk '{print $2}' || echo 80)}

    local progress=0
    if [ "$total" -gt 0 ]; then
        progress=$(( current * 100 / total ))
    fi

    local elapsed=$(( SECONDS - start_time ))

    local eta=0
    if [ "$current" -gt 0 ]; then
        eta=$(( elapsed * (total - current) / current ))
    fi

    local h=$(( eta / 3600 ))
    local m=$(( (eta % 3600) / 60 ))
    local s=$(( eta % 60 ))

    # ë°” ì´ì™¸ ê³ ì • ë¶€ë¶„ ê¸¸ì´ ê³„ì‚°: "prefix: [>] 100% (item_name total/total) ETA 00:00:00"
    local suffix
    suffix=$(printf " %d%% (%s %d/%d) ETA %02d:%02d:%02d" "$progress" "$item_name" "$current" "$total" $h $m $s)
    local overhead=$(( ${#prefix} + 5 + ${#suffix} ))  # ": [" (3) + ">" (1) + "]" (1) + prefix + suffix
    local bar_length=$(( cols - overhead ))
    if [ "$bar_length" -lt 5 ]; then
        bar_length=5
    fi

    local filled=$(( progress * bar_length / 100 ))
    local empty=$(( bar_length - filled ))

    local bar spaces line
    bar=$(printf '%*s' "$filled" '' | tr ' ' '=')
    spaces=$(printf '%*s' "$empty" '')
    line=$(printf "%s: [%s>%s]%s" "$prefix" "$bar" "$spaces" "$suffix")

    printf "\r\033[K%s" "${line:0:cols}"

    if (( current == total )); then
        echo ""
    fi
}

# run_with_bouncing_bar <label> <command...>
# ëª…ë ¹ì„ ì‹¤í–‰í•˜ë©´ì„œ í•˜ë‹¨ì— ë°”ìš´ì‹± ë°” í‘œì‹œ
# ëª…ë ¹ì˜ stdout/stderrë¥¼ stdoutìœ¼ë¡œ íŒ¨ìŠ¤ìŠ¤ë£¨í•˜ë˜, ì¶œë ¥ ì—†ëŠ” êµ¬ê°„ì— ë°”ìš´ì‹± ë°” ì• ë‹ˆë©”ì´ì…˜
# ë°”ìš´ì‹± ë°” ì• ë‹ˆë©”ì´ì…˜ì€ /dev/ttyë¡œ ì§ì ‘ ì¶œë ¥í•˜ì—¬ stdout ìº¡ì²˜ ì‹œì—ë„ í„°ë¯¸ë„ì— í‘œì‹œ
run_with_bouncing_bar() {
    local label=$1
    shift
    local cmd=("$@")
    local tmpfile
    tmpfile=$(mktemp)
    local cols=${COLUMNS:-$(tput cols 2>/dev/null || stty size 2>/dev/null | awk '{print $2}' || echo 80)}
    local pos=0
    local direction=1
    local bounce='<===>'
    local bounce_len=${#bounce}
    # bar_width = í„°ë¯¸ë„ ë„ˆë¹„ - "[label] [" (label+4) - "]" (1) ë¥¼ ë¹¼ì„œ ë™ì  ê³„ì‚°
    local bar_width=$(( cols - ${#label} - 5 ))
    if [ "$bar_width" -lt 10 ]; then
        bar_width=10
    fi
    local reset='\033[0m'
    local bg_color current_lines last_output padding_left padding_right bar_line

    # ëª…ë ¹ì„ ë°±ê·¸ë¼ìš´ë“œë¡œ ì‹¤í–‰, ì¶œë ¥ì„ ì„ì‹œ íŒŒì¼ì— ê¸°ë¡
    "${cmd[@]}" > "$tmpfile" 2>&1 &
    local cmd_pid=$!
    local last_line_count=0

    while kill -0 "$cmd_pid" 2>/dev/null; do
        # ìƒˆ ì¶œë ¥ í™•ì¸ ë° í‘œì‹œ
        current_lines=$(wc -l < "$tmpfile")
        if [ "$current_lines" -gt "$last_line_count" ]; then
            printf '\r\033[K' > /dev/tty
            sed -n "$((last_line_count + 1)),${current_lines}p" "$tmpfile"
            last_line_count=$current_lines
            # ë§ˆì§€ë§‰ ì¶œë ¥ì—ì„œ ë‹¨ê³„ëª… íŒŒì‹±
            last_output=$(tail -1 "$tmpfile" | sed -n 's/.*-- \(.*\) \.\.\..*/\1/p')
            if [ -n "$last_output" ]; then
                label="Backup: $last_output"
            fi
        fi

        # label ë³€ê²½ì— ë§ì¶° bar_width ì¬ê³„ì‚°
        bar_width=$(( cols - ${#label} - 5 ))
        if [ "$bar_width" -lt 10 ]; then
            bar_width=10
        fi
        if [ $pos -ge $((bar_width - bounce_len)) ]; then
            pos=$((bar_width - bounce_len - 1))
            direction=-1
        fi

        # ë¼ë²¨ ë°°ê²½ìƒ‰: critical section(ë…¸ë‘), ì¼ë°˜(ì´ˆë¡)
        bg_color='\033[42;30m'
        if [ "${_trap_active:-0}" -eq 1 ]; then
            bg_color='\033[43;30m'
        fi

        # ë°”ìš´ì‹± ë°” ê·¸ë¦¬ê¸° (tty)
        padding_left=$(printf '%*s' "$pos" '')
        padding_right=$(printf '%*s' "$((bar_width - pos - bounce_len))" '')
        bar_line=$(printf "${bg_color}[%s]${reset} [%s%s%s]" "$label" "$padding_left" "$bounce" "$padding_right")
        printf '\r\033[K%s' "$bar_line" > /dev/tty

        # ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        pos=$((pos + direction))
        if [ $pos -ge $((bar_width - bounce_len)) ]; then
            direction=-1
        elif [ $pos -le 0 ]; then
            direction=1
        fi

        sleep 0.2
    done

    # ë‚¨ì€ ì¶œë ¥ í‘œì‹œ (stdout)
    local final_lines
    final_lines=$(wc -l < "$tmpfile")
    if [ "$final_lines" -gt "$last_line_count" ]; then
        printf '\r\033[K' > /dev/tty
        sed -n "$((last_line_count + 1)),${final_lines}p" "$tmpfile"
    fi

    # ë°”ìš´ì‹± ë°” ì§€ìš°ê¸° (tty)
    printf '\r\033[K' > /dev/tty

    # ì¢…ë£Œ ì½”ë“œ ìˆ˜ì§‘
    wait "$cmd_pid"
    local rc=$?
    rm -f "$tmpfile"
    return $rc
}

# poll_with_bouncing_bar <label> <check_cmd...>
# check_cmdê°€ ì„±ê³µ(exit 0)í•  ë•Œê¹Œì§€ ë°”ìš´ì‹± ë°” + docker logs í‘œì‹œ
poll_with_bouncing_bar() {
    local label=$1
    shift
    local cond=("$@")
    local tmpfile
    tmpfile=$(mktemp)
    local cols=${COLUMNS:-$(tput cols 2>/dev/null || stty size 2>/dev/null | awk '{print $2}' || echo 80)}
    local pos=0
    local direction=1
    local bounce='<===>'
    local bounce_len=${#bounce}
    local reset='\033[0m'
    local bg_color bar_width padding_left padding_right bar_line
    local last_line_count=0
    local tick=0

    # docker logs --follow --tail 0: ìƒˆë¡œìš´ ë¡œê·¸ë§Œ ìŠ¤íŠ¸ë¦¬ë°
    docker logs --follow --tail 0 "$CONTAINER_NAME" > "$tmpfile" 2>&1 &
    local logs_pid=$!

    while ! "${cond[@]}" 2>/dev/null; do
        # ìƒˆ ë¡œê·¸ ì¶œë ¥ í™•ì¸ ë° í‘œì‹œ
        local current_lines
        current_lines=$(wc -l < "$tmpfile")
        if [ "$current_lines" -gt "$last_line_count" ]; then
            printf '\r\033[K' > /dev/tty
            sed -n "$((last_line_count + 1)),${current_lines}p" "$tmpfile"
            last_line_count=$current_lines
        fi

        # bar_width ê³„ì‚°
        bar_width=$(( cols - ${#label} - 5 ))
        if [ "$bar_width" -lt 10 ]; then
            bar_width=10
        fi
        if [ $pos -ge $((bar_width - bounce_len)) ]; then
            pos=$((bar_width - bounce_len - 1))
            direction=-1
        fi

        # ë°°ê²½ìƒ‰
        bg_color='\033[42;30m'
        if [ "${_trap_active:-0}" -eq 1 ]; then
            bg_color='\033[43;30m'
        fi

        # ë°”ìš´ì‹± ë°” ê·¸ë¦¬ê¸°
        padding_left=$(printf '%*s' "$pos" '')
        padding_right=$(printf '%*s' "$((bar_width - pos - bounce_len))" '')
        bar_line=$(printf "${bg_color}[%s]${reset} [%s%s%s]" "$label" "$padding_left" "$bounce" "$padding_right")
        printf '\r\033[K%s' "$bar_line" > /dev/tty

        pos=$((pos + direction))
        if [ $pos -ge $((bar_width - bounce_len)) ]; then
            direction=-1
        elif [ $pos -le 0 ]; then
            direction=1
        fi

        # ì»¨í…Œì´ë„ˆ ì‚¬ë§ ê²€ì‚¬ (5íšŒë§ˆë‹¤ = ~1ì´ˆ ê°„ê²©)
        tick=$((tick + 1))
        if [ $((tick % 5)) -eq 0 ]; then
            print_stacktrace_errors
        fi

        sleep 0.2
    done

    # docker logs í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
    kill "$logs_pid" 2>/dev/null
    wait "$logs_pid" 2>/dev/null

    # ë‚¨ì€ ë¡œê·¸ í‘œì‹œ
    local final_lines
    final_lines=$(wc -l < "$tmpfile")
    if [ "$final_lines" -gt "$last_line_count" ]; then
        printf '\r\033[K' > /dev/tty
        sed -n "$((last_line_count + 1)),${final_lines}p" "$tmpfile"
    fi

    printf '\r\033[K' > /dev/tty
    rm -f "$tmpfile"
}

TAGS_URL="https://gitlab-com.gitlab.io/support/toolbox/upgrade-path/path.json"
echo "Processing GitLab-${GITLAB_EDITION^^} container tags... Location: $TAGS_URL"

PATH_JSON=$(curl -sf "$TAGS_URL")
ALL_TAGS=()

if [ $skip_latest -eq 1 ] && [ -z "$target_version_tag" ]; then
    # N-1: all ë°°ì—´ì˜ ë§ˆì§€ë§‰ ì§ì „ ë²„ì „ì„ íƒ€ê²Ÿìœ¼ë¡œ ì„¤ì •
    n1_version=$(echo "$PATH_JSON" | jq -r '.all[-2]')
    target_version_tag="${n1_version}${TAG_SUFFIX}"
    echo "Skip-latest (N-1) mode: targeting $target_version_tag"
fi

if [ -z "$target_version_tag" ]; then
    mapfile -t ALL_TAGS < <(echo "$PATH_JSON" | jq -r '.all | unique[]' | sort -V | sed "s/\$/${TAG_SUFFIX}/g")
else
    mapfile -t TAGS < <(echo "$PATH_JSON" | jq -r '.all[]' | sed "s/\$/${TAG_SUFFIX}/g")
    CUSTOM_TAGS=("$target_version_tag")
    mapfile -t ALL_TAGS < <(printf "%s\n" "${TAGS[@]}" "${CUSTOM_TAGS[@]}" | sort -Vu)
fi

# partial version resolve
if [ "$_partial_version" -eq 1 ]; then
    resolved=$(printf '%s\n' "${ALL_TAGS[@]}" | grep "^${target_version_tag}\." | sort -V | tail -1)
    if [ -z "$resolved" ]; then
        echo "Error: No tags matching '${target_version_tag}.*' found." >&2
        target_version_tag=
    else
        target_version_tag="$resolved"
        echo "Resolved partial version to: $target_version_tag"
    fi
fi

# 1. í˜„ì¬ ë²„ì „ ì´í›„ë§Œ í•„í„°ë§
UPDATABLE_TAGS=()

count=1
for idx in "${!ALL_TAGS[@]}"; do
    tag="${ALL_TAGS[$idx]}"
    draw_progress $count ${#ALL_TAGS[@]} "Listing tags after $CURRENT_VERSION" 'Item'

    if [[ "$(printf '%s\n%s\n' "$CURRENT_VERSION" "$tag" | sort -V | head -n1)" != "$tag" ]]; then
        UPDATABLE_TAGS+=("$tag")
    fi
    count=$((count + 1))
done

if [ -n "$target_version_tag" ]; then
    TEMP=()
    count=1
    for idx in "${!UPDATABLE_TAGS[@]}"; do
        tag="${UPDATABLE_TAGS[$idx]}"
        draw_progress $count ${#UPDATABLE_TAGS[@]} "Listing tags before $target_version_tag" 'Item'

        if [[ "$(printf '%s\n%s\n' "$tag" "$target_version_tag" | sort -V | head -n1)" == "$tag" ]]; then
            TEMP+=("$tag")
        fi
        count=$((count + 1))
    done

    UPDATABLE_TAGS=("${TEMP[@]}")
fi

# 2. ì—…ê·¸ë ˆì´ë“œ ê²½ë¡œ êµ¬ì„±
# path.json: ì´ë¯¸ í•„ìˆ˜ ê²½ìœ  ë²„ì „ì´ë¯€ë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
UPGRADE_POINTS_ARRAY=("${UPDATABLE_TAGS[@]}")

# CE â†’ EE ì „í™˜ ì‹œ ê°™ì€ ë²„ì „ì˜ EE íƒœê·¸ë¥¼ ë¼ìš°íŒ… í¬ì¸íŠ¸ ë§¨ ì•ì— ì¶”ê°€
if [ "$DETECTED_EDITION" != "$GITLAB_EDITION" ]; then
    EDITION_SWITCH_TAG="${CURRENT_VERSION/-${DETECTED_EDITION}./-${GITLAB_EDITION}.}"
    # ì´ë¯¸ ë°°ì—´ì— í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ì¤‘ë³µ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
    if [[ " ${UPGRADE_POINTS_ARRAY[*]} " != *" $EDITION_SWITCH_TAG "* ]]; then
        UPGRADE_POINTS_ARRAY=("$EDITION_SWITCH_TAG" "${UPGRADE_POINTS_ARRAY[@]}")
    fi
fi

if [ -z "$TARGET_URL" ]; then
    if [ $auto_yes -eq 1 ]; then
        echo "Error: TARGET_URL is required for unattended mode (-y). Use --target-url or TARGET_URL env." >&2
        exit 1
    fi
    echo 'TARGET_URL is not configured yet. Please enter your GitLab server URL.'
    echo 'e.g.: https://gitlab.com'
    echo -n '> '
    read -r TARGET_URL < /dev/tty
    if [ -z "$TARGET_URL" ]; then
        echo 'User abort'
        exit 1
    fi
fi

if [ $auto_yes -eq 1 ] && [ ${#UPGRADE_POINTS_ARRAY[@]} -ge 3 ]; then
    echo "Error: Upgrade path has ${#UPGRADE_POINTS_ARRAY[@]} steps (>= 3). Too many steps for unattended mode (-y)." >&2
    echo "Please run manually without -y flag." >&2
    send_discord_webhook "WARN" "Unattended upgrade aborted" "Upgrade path has ${#UPGRADE_POINTS_ARRAY[@]} steps (>= 3), manual intervention required."
    exit 1
fi

if [ ${#UPGRADE_POINTS_ARRAY[@]} -eq 0 ]; then
    echo "Requirements already satisfied: v$CURRENT_VERSION"

    if ! curl -sf -o /dev/null "$TARGET_URL/users/sign_in"; then
        echo "NOTE: If your GitLab server does not work properly, please edit $(docker inspect "$CONTAINER_NAME" --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' | tr ' ' '\n' | grep /etc/gitlab | awk -F ':' '{ print $1 }')/gitlab.rb file or 'docker exec -it $CONTAINER_NAME /bin/bash && vi /etc/gitlab/gitlab.rb'"
    fi
    exit 0
fi

echo -e "\nWould you like to upgrade GitLab server from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}?"
echo "This action cannot be undone. PLEASE BACKUP GitLab drive BEFORE STARTING UPDATE..."
echo "You should update pointing releases too. ROUTING COUNT: ${#UPGRADE_POINTS_ARRAY[@]}"
if [ ${#UPGRADE_POINTS_ARRAY[@]} -lt 10 ]; then
    for idx in "${!UPGRADE_POINTS_ARRAY[@]}"; do
        echo -e "\t$((idx + 1)). ${UPGRADE_POINTS_ARRAY[$idx]}"
    done
fi
if [ ${#UPGRADE_POINTS_ARRAY[@]} -le 5 ]; then
    echo -e "\ttraceroute: ${UPGRADE_POINTS_ARRAY[*]}"
fi
echo "Follow this link to get more information: https://gitlab-com.gitlab.io/support/toolbox/upgrade-path/?current=${CURRENT_VERSION%%-*}&target=${UPGRADE_POINTS_ARRAY[-1]%%-*}&distro=docker&edition=${GITLAB_EDITION}"
echo ''
echo -e "\t- I understood that this action DOES NOT SUPPORT rollback"
echo -e "\t- I understood that this action may take a long time due to the ROUTING COUNT."
echo -e "\t- I checked container restart policy: $(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' "$CONTAINER_NAME")"
echo -e "\t- I checked container PORTS: $(docker inspect "$CONTAINER_NAME" --format='{{range $p, $conf := .NetworkSettings.Ports}}{{$p}} -> {{(index $conf 0).HostPort}} {{end}}')"
echo -e "\t- I checked container DRIVE: $(docker inspect "$CONTAINER_NAME" --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}')"
echo -e "\t- I checked gitlab external_url in gitlab.rb file: $(docker exec "$CONTAINER_NAME" grep '^external_url' /etc/gitlab/gitlab.rb | awk -F"'" '{print $2}')"
echo -e "\t- I checked gitlab backup_path in gitlab.rb file: $(docker exec "$CONTAINER_NAME" grep "'backup_path'" /etc/gitlab/gitlab.rb | awk -F"=" '{print $2}' | sed 's/\"//g' | sed 's/^ //')"
if [ "$(docker exec "$CONTAINER_NAME" gitlab-psql -tAc "SELECT COUNT(*) FROM ci_runners;")" -eq 0 ]; then
    echo -e "\t- I checked this GitLab server has not configured any runners yet."
else
    echo ''
    echo -e "\t- I checked this GitLab server is configured with the following runners:"
    docker exec "$CONTAINER_NAME" gitlab-psql -c "SELECT id, description, contacted_at, active FROM ci_runners ORDER BY id;"
    echo ''
    PAUSED_RUNNER_IDS=""
    active_runners=$(docker exec "$CONTAINER_NAME" gitlab-psql -tAc "SELECT COUNT(*) FROM ci_runners WHERE active = true;")
    if [ "$active_runners" -gt 0 ]; then
        echo "WARNING: $active_runners active runner(s) detected. Runners should be paused before upgrading."
        if [ $auto_yes -eq 0 ]; then
            echo -n "Pause runners automatically? (Y/n) > "
            read -r runner_confirm < /dev/tty
            if [ "$runner_confirm" == "n" ] || [ "$runner_confirm" == "N" ]; then
                echo "Aborted. Pause runners in Admin > Runners, then re-run this script."
                exit 1
            fi
        fi
        echo "Pausing $active_runners active runner(s)..."
        PAUSED_RUNNER_IDS=$(docker exec "$CONTAINER_NAME" gitlab-psql -tAc "SELECT id FROM ci_runners WHERE active = true;")
        docker exec "$CONTAINER_NAME" gitlab-psql -c "UPDATE ci_runners SET active = false WHERE active = true;" > /dev/null
        echo "Runners paused. They will be resumed after the upgrade."
    fi
fi
echo -e "\t- I checked TARGET_URL is valid: $TARGET_URL"

if [ $auto_yes -eq 1 ]; then
    echo -e "\nAuto-confirmed (-y mode)."
else
    echo -en "\nI accept the above notice and continue this job (y/N) > "
    read -r n < /dev/tty
    if [ "$n" != "y" ] && [ "$n" != "Y" ]; then
        echo 'User abort' >&2
        exit 1
    fi
fi

send_discord_webhook "NOTE" "Updating GitLab now!" "GitLab will be upgraded from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}"
auto_restart_enabled=$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' "$CONTAINER_NAME")

# 0. ë””ìŠ¤í¬ ì—¬ìœ  ê³µê°„ ì‚¬ì „ ê²€ì¦
check_disk_space

echo "Creating backups for $CURRENT_VERSION. Please wait until backup process is completed..."
if docker exec "$CONTAINER_NAME" which gitlab-backup &>/dev/null; then
    run_with_bouncing_bar "Backup" docker exec "$CONTAINER_NAME" gitlab-backup create
else
    run_with_bouncing_bar "Backup" docker exec "$CONTAINER_NAME" gitlab-rake gitlab:backup:create
fi
BACKUP_DIR=$(docker exec "$CONTAINER_NAME" grep "'backup_path'" /etc/gitlab/gitlab.rb | awk -F"=" '{ print $2 }' | sed 's/\"//g' | sed 's/^ //')
docker exec "$CONTAINER_NAME" sh -c "cp /etc/gitlab/gitlab-secrets.json $BACKUP_DIR/gitlab-secrets.json.${CURRENT_VERSION}-backup"
docker exec "$CONTAINER_NAME" sh -c "cp /etc/gitlab/gitlab.rb $BACKUP_DIR/gitlab.rb.${CURRENT_VERSION}-backup"

# Secrets ë¬´ê²°ì„± ê¸°ì¤€ì„  í™•ì¸
if ! check_secrets_integrity "pre-upgrade"; then
    if [ $auto_yes -eq 1 ]; then
        echo "Aborted due to secrets integrity check failure (-y mode)." >&2
        exit 1
    fi
    echo -n "Continue despite secrets integrity warning? (y/N) > "
    read -r secrets_confirm < /dev/tty
    if [ "$secrets_confirm" != "y" ] && [ "$secrets_confirm" != "Y" ]; then
        echo "Aborted due to secrets integrity check failure." >&2
        exit 1
    fi
fi

# ì—ë””ì…˜ ì „í™˜ (ê°™ì€ ë²„ì „ì—ì„œ CE â†’ EE)
if [ "$DETECTED_EDITION" != "$GITLAB_EDITION" ]; then
    echo "Switching edition at current version: $CURRENT_VERSION -> $EDITION_SWITCH_TAG"
    send_discord_webhook "INFO" "Switching edition: $DETECTED_EDITION -> $GITLAB_EDITION" "Same version edition switch before version upgrades"

    wait_for_background_migrations
    check_gitlab_server_healthy 0

    enter_critical

    if docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        echo "stopping $CURRENT_VERSION container..."
        run_with_bouncing_bar "Stopping" bash -c "
            docker logs --follow --tail 0 \"$CONTAINER_NAME\" &
            logs_pid=\$!
            docker stop \"$CONTAINER_NAME\" 2>&1
            kill \$logs_pid 2>/dev/null
            wait \$logs_pid 2>/dev/null
        "
        echo 'done'
    fi
    echo -n "removing $CURRENT_VERSION container..."
    docker container rm "$CONTAINER_NAME" &> /dev/null
    echo ' done'

    echo -n "removing previous $CURRENT_VERSION image..."
    docker image rm "gitlab/gitlab-${DETECTED_EDITION}:$CURRENT_VERSION" &> /dev/null
    echo ' done'

    pull_with_retry "$GITLAB_IMAGE:$EDITION_SWITCH_TAG"

    # shellcheck disable=SC2086
    docker run -d --name "$CONTAINER_NAME" $VOLUMES $PORTS "$GITLAB_IMAGE:$EDITION_SWITCH_TAG"

    exit_critical

    wait_for_http_ready "$GITLAB_IMAGE:$EDITION_SWITCH_TAG"
    wait_for_healthy "$GITLAB_IMAGE:$EDITION_SWITCH_TAG"

    wait_for_background_migrations
    check_migration_status

    CURRENT_VERSION=$EDITION_SWITCH_TAG
    echo "Edition switch completed: now running $GITLAB_IMAGE:$EDITION_SWITCH_TAG"
    send_discord_webhook "NOTE" "Edition switch completed" "Now running $GITLAB_IMAGE:$EDITION_SWITCH_TAG"

    # ì—ë””ì…˜ ì „í™˜ í¬ì¸íŠ¸ë¥¼ ë¼ìš°íŒ… ë°°ì—´ì—ì„œ ì œê±° (ì´ë¯¸ ì²˜ë¦¬ë¨)
    UPGRADE_POINTS_ARRAY=("${UPGRADE_POINTS_ARRAY[@]:1}")
fi

index=1
CNT_VERSION=$CURRENT_VERSION
for ver in "${UPGRADE_POINTS_ARRAY[@]}"; do
    send_discord_webhook "INFO" "GitLab server is upgrading now! ($index/${#UPGRADE_POINTS_ARRAY[@]})" "Please wait until upgrading process is done."
    echo "Updating $CNT_VERSION to $ver... ($index/${#UPGRADE_POINTS_ARRAY[@]})"

    # ë‹¤ìŒ ë²„ì „ ì´ë¯¸ì§€ ì‚¬ì „ Pull (ë°±ê·¸ë¼ìš´ë“œ)
    PULL_PID=
    if [ $index -lt ${#UPGRADE_POINTS_ARRAY[@]} ]; then
        next_ver="${UPGRADE_POINTS_ARRAY[$index]}"
        docker pull "$GITLAB_IMAGE:$next_ver" &> /dev/null &
        PULL_PID=$!
    fi

    if ! docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        docker start "$CONTAINER_NAME" &> /dev/null
        wait_for_healthy "$GITLAB_IMAGE:$CNT_VERSION"
    fi

    wait_for_background_migrations
    check_gitlab_server_healthy 0

    enter_critical

    if docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        echo "stopping $CNT_VERSION container..."
        run_with_bouncing_bar "Stopping" bash -c "
            docker logs --follow --tail 0 \"$CONTAINER_NAME\" &
            logs_pid=\$!
            docker stop \"$CONTAINER_NAME\" 2>&1
            kill \$logs_pid 2>/dev/null
            wait \$logs_pid 2>/dev/null
        "
        echo 'done'
    fi
    echo -n "removing $CNT_VERSION container..."
    docker container rm "$CONTAINER_NAME" &> /dev/null
    echo ' done'

    echo -n "removing previous $CNT_VERSION image..."
    docker image rm "$GITLAB_IMAGE:$CNT_VERSION" &> /dev/null
    echo ' done'

    # ì‚¬ì „ Pull ì™„ë£Œ ëŒ€ê¸°
    if [ -n "$PULL_PID" ]; then
        wait "$PULL_PID" 2>/dev/null || true
        PULL_PID=
    fi

    pull_with_retry "$GITLAB_IMAGE:$ver"

    # shellcheck disable=SC2086
    docker run -d --name "$CONTAINER_NAME" $VOLUMES $PORTS "$GITLAB_IMAGE:$ver"

    exit_critical

    wait_for_http_ready "$GITLAB_IMAGE:$ver"
    wait_for_healthy "$GITLAB_IMAGE:$ver"

    # ë°±ê·¸ë¼ìš´ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ ëŒ€ê¸°
    wait_for_background_migrations
    # ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒíƒœ ê²€ì¦
    check_migration_status

    if [ $index -lt ${#UPGRADE_POINTS_ARRAY[@]} ]; then
        echo "gitlab-$GITLAB_EDITION $ver update completed. remaining jobs: $((${#UPGRADE_POINTS_ARRAY[@]} - index))"
    else
        echo "gitlab-$GITLAB_EDITION $ver update completed."
        send_discord_webhook "NOTE" "Upgrade process now completed!" "Please wait until GitLab server is ready."
    fi
    CNT_VERSION=$ver
    index=$((index + 1))
done

check_gitlab_server_healthy 1

# ìµœì¢… ì‹œí¬ë¦¿ ë¬´ê²°ì„± í™•ì¸
check_secrets_integrity "post-upgrade"

# ì—…ê·¸ë ˆì´ë“œ ì „ ë¹„í™œì„±í™”í•œ ëŸ¬ë„ˆ ë³µì›
if [ -n "$PAUSED_RUNNER_IDS" ]; then
    id_list=$(echo "$PAUSED_RUNNER_IDS" | tr -s '[:space:]' ',' | sed 's/^,//;s/,$//')
    docker exec "$CONTAINER_NAME" gitlab-psql -c "UPDATE ci_runners SET active = true WHERE id IN ($id_list);" > /dev/null
    echo "Resumed previously paused runners: $id_list"
    send_discord_webhook "NOTE" "Runners resumed" "IDs: $id_list"
fi

if [ "$auto_restart_enabled" == "$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' "$CONTAINER_NAME")" ] && [ "$auto_restart_enabled" == 'no' ]; then
    if [ $auto_yes -eq 0 ]; then
        echo "Would you like to change RestartPolicy from $auto_restart_enabled to always?"
        echo 'AVAILABLE OPTIONS'
        echo -e 'no\t\t\t\tDo not automatically restart the container. (Default, Current)'
        echo -e 'on-failure[:max-retries]\tRestart the container if it exits due to an error, which manifests as a non-zero exit code.'
        echo -e 'always\t\t\t\tAlways restart the container if it stops. If it is manually stopped, it is restarted only when Docker daemon restarts or the container itself is manually restarted.'
        echo -e 'unless-stopped\t\t\tSimilar to always, except that when the container is stopped (manually or otherwise), it is not restarted even after Docker daemon restarts.'
        echo -n '> '
        read -r n < /dev/tty
        case "$n" in
            no|always|unless-stopped|on-failure|on-failure:[0-9]*)
                docker update --restart="$n" "$CONTAINER_NAME"
                ;;
            *)
                # shellcheck disable=SC2016
                echo 'If you want to edit RestartPolicy value later, please run `docker update --restart=<rule> <container-name>` to apply.'
                ;;
        esac
    fi
elif [ "$auto_restart_enabled" != "$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' "$CONTAINER_NAME")" ]; then
    echo "Updating gitlab RestartPolicy from $(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' "$CONTAINER_NAME") to $auto_restart_enabled"
    docker update --restart="$auto_restart_enabled" "$CONTAINER_NAME" &> /dev/null
fi

echo "Successfully updated GitLab server from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}"
echo "Updated traceroute: ${UPGRADE_POINTS_ARRAY[*]}"
send_discord_webhook "NOTE" "Successfully upgraded GitLab server!" "GitLab version changed from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}"

exit 0

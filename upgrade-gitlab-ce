#!/usr/bin/env bash

PAGE_SIZE=${PAGE_SIZE:-25}
BACKUP_DIR=
DISCORD_URL=${DISCORD_URL:-}

use_local_versions=/dev/null
extract_versions_only=0
use_all_tags=0
target_version_tag=
auto_restart_enabled=no
_in_stacktrace=0

if [ "$1" == "--help" ] || [ "$1" == "help" ]; then
    echo "Usage: $0 [--all-tags [--page-size=25]] [--target-url=http] [--extract | [--version=0.0.0] [FILE]]"

    echo -e '\n\e[0;1mOPTIONS\e[m'
    echo -e "--help\t\t\tShow this help."
    echo -e "--extract\t\tDownload gitlab-ce released tags file. (aka. export)"
    echo -e "\t\t\tTags file will be saved to /tmp/gitlab-released-tags.txt"
    echo -e "--all-tags\t\tParse all tags from Docker Hub instead of GitLab upgrade-path site."
    echo -e "--version=0.0.0\t\tUse provided tag instead of latest tag."
    echo -e "--target-url=http\tPerform a simple connection test for your GitLab server."
    echo -e "--discord-url=http\tNotify via Discord webhook."
    echo -e "--page-size=25\t\tSet the number of tags per page with --all-tags flag."
    echo -e "FILE\t\t\tUse provided file with already ASC sorted contents."

    echo -e '\n\e[0;1mENV VALUES\e[m'
    echo -e "TARGET_URL=http\t\tSame as --target-url flag."
    echo -e "DISCORD_URL=http\tSame as --discord-url flag."
    echo -e "PAGE_SIZE=25\t\tSame as --page-size flag."
    exit 0
else
    params=("${@}")
    for i in "${!params[@]}"; do
        if [[ "${params[$i]}" == "-"* ]]; then
            temp=$(echo "${params[$i]}" | awk -F '=' '{ print $2 }')

            if [ "${params[$i]}" == "--all-tags" ]; then
                use_all_tags=1
            elif [ "${params[$i]}" == "--extract" ] || [ "${params[$i]}" == "--export" ]; then
                if [ "$use_local_versions" == '/dev/null' ] && [ -z "$target_version_tag" ]; then
                    extract_versions_only=1
                fi
            elif [[ "${params[$i]}" == "--version"* ]]; then
                if [ -n "$target_version_tag" ]; then
                    echo "Warning: Overriding target_version_tag from $target_version_tag to $temp"
                fi
                if [ "$(echo "$temp" | grep -c '\-ce')" -ne 1 ]; then
                    target_version_tag="$temp-ce.0"
                else
                    target_version_tag=$temp
                fi

                if curl -sf "https://hub.docker.com/v2/repositories/gitlab/gitlab-ce/tags/$target_version_tag" &> /dev/null; then
                    echo "Using $target_version_tag instead of latest"
                    extract_versions_only=0
                else
                    echo "Error: No such $target_version_tag tag in Docker Hub. Using alternative tag: latest" >&2
                    target_version_tag=
                fi
            elif [[ "${params[$i]}" == "--target-url"* ]]; then
                if [ -n "$TARGET_URL" ]; then
                    echo "Warning: Overriding TARGET_URL from $TARGET_URL to $temp"
                fi
                TARGET_URL=$temp
            elif [[ "${params[$i]}" == "--discord-url"* ]]; then
                if [ -n "$DISCORD_URL" ]; then
                    echo "Warning: Overriding DISCORD_URL from $DISCORD_URL to $temp"
                fi
                DISCORD_URL=$temp
            elif [[ "${params[$i]}" == "--page-size"* ]]; then
                if [ -n "$PAGE_SIZE" ]; then
                    echo "Warning: Overriding PAGE_SIZE from $PAGE_SIZE to $temp"
                fi
                PAGE_SIZE=$temp
            fi
        elif [ -f "${params[$i]}" ] && [ "$use_local_versions" == '/dev/null' ] && [ $extract_versions_only -eq 0 ]; then
            echo "Using ${params[$i]} file to reduce time spent sorting version tags"
            if ! cat -A "${params[$i]}" | tail -n1 | grep '\$' &> /dev/null; then
                echo '' >> "${params[$i]}"
            fi

            grep -viE '(rc|nightly|latest)' "${params[$i]}" > "${params[$i]}.tmp" && mv "${params[$i]}.tmp" "${params[$i]}"
            requirements=$(cat "${params[$i]}" | grep -cE '^[0-9]+\.[0-9]+\.[0-9]+-ce\.[0-9]+$')
            total=$(cat "${params[$i]}" | wc -l)
            if [ $requirements -ne $total ]; then
                echo "Error: Provided file contents do not contain gitlab-ce version tags" >&2
                cat "${params[$i]}" | head -n 10 >&2
                continue
            else
                use_local_versions=${params[$i]}
            fi
        fi
    done
fi

if ! which docker &> /dev/null; then
    echo "Docker is not installed on this system. $(uname -a)" >&2
    if [ -d /usr/syno ]; then
        echo 'Please install Docker (Obsolete) or ContainerManager before running this script.' >&2
        echo -e '\nRef:\n\thttps://www.synology.com/dsm/feature/container-manager' >&2
    else
        echo 'Please install DockerEngine or DockerDesktop before running this script.' >&2
        echo -e '\nRef:\n\thttps://docs.docker.com/engine/install\n\thttps://docs.docker.com/desktop' >&2
    fi
    exit 1
fi

if ! id | grep docker &> /dev/null && [ $UID -ne 0 ]; then
    echo "The $USER user does not have enough docker.sock permissions." >&2
    exit 1
fi

# --------------------------
# üîç gitlab/gitlab-ce Ïª®ÌÖåÏù¥ÎÑà ÏûêÎèô Í∞êÏßÄ
# --------------------------
CONTAINER_CANDIDATES=$(docker ps -a --format "{{.Image}}\t{{.Names}}" | grep "^gitlab/gitlab-ce" | awk '{print $2}')
CONTAINER_COUNT=$(echo "$CONTAINER_CANDIDATES" | grep -c .)

if [ $CONTAINER_COUNT -eq 0 ]; then
    echo 'Error: No container using gitlab/gitlab-ce image found.' >&2
    exit 1
elif [ $CONTAINER_COUNT -gt 1 ]; then
    echo 'Error: Multiple gitlab/gitlab-ce containers found:' >&2
    echo "  - ${CONTAINER_CANDIDATES//$'\n'/$'\n'  - }" >&2
    echo 'Please keep only one container running or specify which one to upgrade.' >&2
    exit 1
fi

CONTAINER_NAME=$CONTAINER_CANDIDATES
echo "Detected gitlab container: $CONTAINER_NAME"

# --------------------------
# 1Ô∏è‚É£ Î≥ºÎ•® ÎßàÏö¥Ìä∏ Ï∂îÏ∂ú
# --------------------------
VOLUMES=$(docker inspect $CONTAINER_NAME --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' \
    | tr ' ' '\n' \
    | sed '/^$/d' \
    | awk '{printf "-v %s ", $0}' \
    | sed 's/ $//')

# --------------------------
# 2Ô∏è‚É£ Ìè¨Ìä∏ Îß§Ìïë Ï∂îÏ∂ú
# --------------------------
PORTS=$(docker inspect $CONTAINER_NAME --format='{{range $p, $conf := .HostConfig.PortBindings}}{{$p}}:{{(index $conf 0).HostPort}} {{end}}' \
    | tr ' ' '\n' \
    | sed '/^$/d' \
    | sed 's/\/tcp//g' \
    | awk -F: '{printf "-p %s:%s ", $2, $1}')

send_discord_webhook() {
    if [ -z "$DISCORD_URL" ] || [ $# -ne 3 ]; then
        return 1
    fi

    format_title=
    hex_color=
    if [ "$1" == "ERR" ]; then
        hex_color=15158332 #Îπ®Í∞ï
        format_title="üõë $2"
    elif [ "$1" == "WARN" ]; then
        hex_color=15904252 #Ï£ºÌô©
        format_title="‚ö†Ô∏è $2"
    elif [ "$1" == "NOTE" ]; then
        hex_color=3447003  #ÌååÎûë
        format_title="üîî $2"
    elif [ "$1" == "INFO" ]; then
        format_title="‚ÑπÔ∏è $2"
        hex_color=3066993  #Ï¥àÎ°ù
    else
        return 1
    fi

    JSON_PAYLOAD=$(jq -n \
        --arg title "$format_title" \
        --arg description "$3" \
        --argjson color "$hex_color" \
        '{
            "embeds": [{
                "title": $title,
                "color": $color,
                "fields": [
                    {"name": "Description", "value": $description, "inline": false}
                ],
                "footer": {"text": "GitLab upgrade helper"},
                "timestamp": (now | todate)
            }]
        }'
    )
    curl -s -H "Content-Type: application/json" \
        -X POST \
        -d "$JSON_PAYLOAD" \
        "$DISCORD_URL" &> /dev/null
}

check_gitlab_server_healthy() {
    if docker exec $CONTAINER_NAME gitlab-ctl status; then
        docker exec $CONTAINER_NAME gitlab-ctl reconfigure
        docker exec $CONTAINER_NAME gitlab-ctl pg-upgrade
        docker exec $CONTAINER_NAME gitlab-rake db:migrate
        docker exec $CONTAINER_NAME gitlab-ctl restart
        docker exec $CONTAINER_NAME gitlab-ctl status || print_stacktrace_errors
    else
        print_stacktrace_errors
    fi
}

print_stacktrace_errors() {
    if [ $_in_stacktrace -eq 1 ]; then
        return 0
    fi
    if [ "$(docker inspect --format='{{.State.ExitCode}}' $CONTAINER_NAME)" -ne 0 ]; then
        _in_stacktrace=1
        echo -e "\nError: gitlab container died with the following status code: $(docker inspect --format='{{.State.ExitCode}}' $CONTAINER_NAME)" >&2

        if [ $# -eq 2 ]; then
            # ÏóÖÍ∑∏Î†àÏù¥ÎìúÏóê Ïã§Ìå®ÌñàÏúºÎÇò Îã§Ïö¥Í∑∏Î†àÏù¥ÎìúÍ∞Ä Í∞ÄÎä•Ìï† Í≤ΩÏö∞
            echo "An error occurred while installing $1. Will try to roll back to the following previous version: $2." >&2
            send_discord_webhook "ERR" "Installation was rejected" "$1 died with non-zero exit code. Roll back to $2"

            if docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
                echo -n "stopping $1 container with SIGINT signal..."
                docker stop $CONTAINER_NAME &> /dev/null
                echo ' done'
            fi
            echo -n "removing $1 container..."
            docker container rm $CONTAINER_NAME &> /dev/null
            echo ' done'

            echo -n "removing previous $1 image..."
            docker image rm "$(docker images --format "{{.ID}}" gitlab/gitlab-ce)" &> /dev/null
            echo ' done'

            docker pull gitlab/gitlab-ce:$2
            docker run -d --name $CONTAINER_NAME $VOLUMES $PORTS gitlab/gitlab-ce:$2

            echo -n "waiting until gitlab/gitlab-ce:$2 server boots... "
            spinner='/-\|'
            n=${#spinner}
            echo -n ' '
            while [ "$(curl -sf -o /dev/null $TARGET_URL/explore/projects -w "%{http_code}\n")" != '200' ]; do
                printf '\b%s' "${spinner:i++%n:1}"
                print_stacktrace_errors
                sleep 1
            done
            printf '\b\b%s' " "
            echo 'done'

            echo -n "waiting until gitlab/gitlab-ce:$2 container is ready... "
            spinner='/-\|'
            n=${#spinner}
            echo -n ' '
            while [ "$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_NAME | grep -v unhealthy | grep -c healthy)" -ne 1 ]; do
                printf '\b%s' "${spinner:i++%n:1}"
                print_stacktrace_errors
                sleep 1
            done
            printf '\b\b%s' " "
            echo 'done'

            check_gitlab_server_healthy
            echo "Successfully downgraded GitLab server from $1 to $2"
            echo 'Please re-run this script to continue upgrade process.'
            send_discord_webhook "NOTE" "Successfully downgraded to $2" ""
            touch /tmp/upgrade-gitlab-ce.lock
            exit 2
        else
            # ÏóÖÍ∑∏Î†àÏù¥Îìú Î∞è Îã§Ïö¥Í∑∏Î†àÏù¥Îìú Î™®Îëê Ïã§Ìå®Ïãú
            docker logs --tail 200 $CONTAINER_NAME >&2
            send_discord_webhook "ERR" "FATAL ERROR occurred!" "See: https://docs.gitlab.com/administration/backup_restore"
            echo -e '\e[1;5;37;41mFATAL ERROR: MANUAL INTERVENTION IS REQUIRED\e[0m' >&2
            echo 'upgrade-gitlab-ce script does not recover this issue. Please restore previous backup with `gitlab-rake gitlab:backup:restore`' >&2
            echo 'For more information, please visit: https://docs.gitlab.com/administration/backup_restore' >&2
            if [ -z "$BACKUP_DIR" ]; then
                BACKUP_DIR=$(docker exec $CONTAINER_NAME grep "'backup_path'" /etc/gitlab/gitlab.rb 2>/dev/null | awk -F"=" '{ print $2 }' | sed 's/\"//g' | sed 's/^ //')
            fi
            echo "backup_path: $BACKUP_DIR" >&2
            exit 1
        fi
    fi
}

if ! docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
    echo -n 'waiting until GitLab server is back online... '
    docker start $CONTAINER_NAME &> /dev/null
    spinner='/-\|'
    n=${#spinner}
    echo -n ' '
    while [ "$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_NAME | grep -v unhealthy | grep -c healthy)" -ne 1 ]; do
        printf '\b%s' "${spinner:i++%n:1}"
        print_stacktrace_errors
        sleep 1
    done
    printf '\b\b%s' " "
    echo 'done'
fi

CURRENT_VERSION=$(docker exec $CONTAINER_NAME dpkg -l | grep gitlab | awk '{ print $3 }')
if [ -z "$CURRENT_VERSION" ]; then
    exit 1
fi

start_time=$SECONDS

draw_progress() {
    local current=$1
    local total=$2
    local bar_length=30
    local prefix=$3
    local item_name=$4

    # ÏßÑÌñâÎ•† Í≥ÑÏÇ∞
    local progress=0
    if [ $total -gt 0 ]; then
        progress=$(( current * 100 / total ))
    fi

    # Ï±ÑÏõåÏßÑ Í∏∏Ïù¥ Í≥ÑÏÇ∞
    local filled=$(( progress * bar_length / 100 ))
    local empty=$(( bar_length - filled ))

    # Î∞î ÎßåÎì§Í∏∞
    local bar=""
    local spaces=""
    if [ $filled -gt 0 ]; then
        bar=$(printf "%0.s=" $(seq 1 $filled))
    fi
    if [ $empty -gt 0 ]; then
        spaces=$(printf "%0.s " $(seq 1 $empty))
    fi

    # Í≤ΩÍ≥º ÏãúÍ∞Ñ
    local elapsed=$(( SECONDS - start_time ))

    # ETA Í≥ÑÏÇ∞ (current > 0Ïùº ÎïåÎßå)
    local eta=0
    if [ $current -gt 0 ]; then
        eta=$(( elapsed * (total - current) / current ))
    fi

    # ETAÎ•º HH:MM:SSÎ°ú Î≥ÄÌôò
    local h=$(( eta / 3600 ))
    local m=$(( (eta % 3600) / 60 ))
    local s=$(( eta % 60 ))

    # Ï∂úÎ†•
    printf "\r%s: [%s>%s] %d%% (%s %d/%d) ETA %02d:%02d:%02d" \
        "$prefix" "$bar" "$spaces" "$progress" "$item_name" "$current" "$total" $h $m $s

    # ÎßàÏßÄÎßâÏù¥Î©¥ Ï§ÑÎ∞îÍøà
    if (( current == total )); then
        echo ""
    fi
}

if [ "$use_local_versions" == '/dev/null' ]; then
    if [ $use_all_tags -eq 0 ]; then
        TAGS_URL="https://gitlab-com.gitlab.io/support/toolbox/upgrade-path/path.json"

        echo "Processing GitLab-CE container tags... Location: $TAGS_URL"
        ALL_TAGS=()
        if [ -z "$target_version_tag" ]; then
            mapfile -t ALL_TAGS < <(curl -sf "$TAGS_URL" | jq -r '.all | unique[]' | sort -V | sed 's/$/-ce.0/g')
        else
            mapfile -t TAGS < <(curl -sf "$TAGS_URL" | jq -r '.all[]' | sed 's/$/-ce.0/g')
            CUSTOM_TAGS=("$target_version_tag")
            mapfile -t ALL_TAGS < <(printf "%s\n" "${TAGS[@]}" "${CUSTOM_TAGS[@]}" | sort -Vu)
        fi

        if [ $extract_versions_only -eq 1 ]; then
            echo "${ALL_TAGS[@]}" | tr ' ' '\n' > /tmp/gitlab-released-tags.txt
            if [ "$(wc -l < /tmp/gitlab-released-tags.txt)" -gt 3 ]; then
                echo -e '\nNote: Successfully exported gitlab-ce released tags. These tags are already sorted in ASC order. Location: /tmp/gitlab-released-tags.txt'
                exit 0
            else
                echo -e '\nError: Failed to export gitlab-ce released tags. Internal error occurred.' >&2
                rm /tmp/gitlab-released-tags.txt &> /dev/null
                exit 1
            fi
        fi
    else
        TAGS_URL="https://hub.docker.com/v2/repositories/gitlab/gitlab-ce/tags/?page_size=$PAGE_SIZE"

        # 1. Ï≤´ ÌéòÏù¥ÏßÄ ÏöîÏ≤≠
        RESPONSE=$(curl -sL "$TAGS_URL")
        TOTAL_COUNT=$(echo "$RESPONSE" | jq '.count')

        # 2. Ï†ÑÏ≤¥ ÌéòÏù¥ÏßÄ Ïàò Í≥ÑÏÇ∞
        TOTAL_PAGES=$(( (TOTAL_COUNT + PAGE_SIZE - 1) / PAGE_SIZE ))

        ALL_TAGS=()

        echo "Spooling GitLab-CE container tags... Location: $TAGS_URL"
        while [ -n "$TAGS_URL" ]; do
            RESPONSE=$(curl -sL "$TAGS_URL")
            mapfile -t TAGS < <(echo "$RESPONSE" | jq -r '.results[].name')
            if [ ${#TAGS[@]} -eq 0 ]; then
                break  # Îçî Ïù¥ÏÉÅ ÌÉúÍ∑∏ ÏóÜÏùå
            else
                CURRENT_PAGE=$(echo "$TAGS_URL" | grep -oP 'page=\K[0-9]+' || echo 1)
                draw_progress $CURRENT_PAGE $TOTAL_PAGES 'Querying GitLab Releases' 'Page'
            fi
            ALL_TAGS+=("${TAGS[@]}")
            TAGS_URL=$(echo "$RESPONSE" | jq -r '.next // empty')
        done

        echo -e "\nSorting ASC GitLab-CE released tags..."

        # Î≤ÑÏ†Ñ Ï†ïÎ†¨
        printf '%s\n' "${ALL_TAGS[@]}" | tr ' ' '\n' > /tmp/gitlab-parsed.log

        RAW_TAGS_N=$(sort -V /tmp/gitlab-parsed.log | grep -viE '(rc|nightly|latest)')
        count=1
        mapfile -t RAW_TAGS <<< "$RAW_TAGS_N"

        if [ ${#RAW_TAGS[@]} -lt 2 ]; then
            echo 'Error: Unexpected EOF while parsing version tags' >&2
            exit 1
        fi

        ALL_TAGS=()
        for idx in "${!RAW_TAGS[@]}"; do
            tag="${RAW_TAGS[$idx]}"
            if [ $extract_versions_only -eq 1 ]; then
                draw_progress $count ${#RAW_TAGS[@]} "Exporting provided contents" 'Item'
            else
                draw_progress $count ${#RAW_TAGS[@]} "Including provided contents" 'Item'
            fi

            # Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
            ALL_TAGS+=("$tag")
            count=$((count + 1))

            # Ï≤´ Î≤àÏß∏ ÎπÑÍµê
            if [ $((idx + 1)) -lt ${#RAW_TAGS[@]} ]; then
                next_tag="${RAW_TAGS[$((idx + 1))]}"
                first=$(printf '%s\n%s\n' "$tag" "$next_tag" | sort -V | head -n1)
                if ! [[ "$first" == "$tag" ]]; then
                    echo -e "\nError: Tags are NOT in ASC order: $tag > $next_tag" >&2
                    exit 1
                fi
            fi
        done
        rm /tmp/gitlab-parsed.log &> /dev/null
        if [ $extract_versions_only -eq 1 ]; then
            echo "${ALL_TAGS[@]}" | tr ' ' '\n' > /tmp/gitlab-released-tags.txt
            if [ "$(wc -l < /tmp/gitlab-released-tags.txt)" -gt 3 ]; then
                echo -e '\nNote: Successfully exported gitlab-ce released tags. These tags are already sorted in ASC order. Location: /tmp/gitlab-released-tags.txt'
                exit 0
            else
                echo -e '\nError: Failed to export gitlab-ce released tags. Internal error occurred.' >&2
                rm /tmp/gitlab-released-tags.txt &> /dev/null
                exit 1
            fi
        fi
    fi
else
    tr ' ' '\n' < "$use_local_versions" > "${use_local_versions}.tmp" && mv "${use_local_versions}.tmp" "$use_local_versions"
    RAW_TAGS_N=$(sort -V "$use_local_versions" | grep -viE '(rc|nightly|latest)')
    count=1
    mapfile -t RAW_TAGS <<< "$RAW_TAGS_N"

    if [ -n "$target_version_tag" ]; then
        CUSTOM_TAGS=("$target_version_tag")
        mapfile -t RAW_TAGS < <(printf "%s\n" "${RAW_TAGS[@]}" "${CUSTOM_TAGS[@]}" | sort -Vu)
    fi

    for idx in "${!RAW_TAGS[@]}"; do
        tag="${RAW_TAGS[$idx]}"
        draw_progress $count ${#RAW_TAGS[@]} "Verifying provided contents" 'Item'

        # Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
        ALL_TAGS+=("$tag")
        count=$((count + 1))

        # Ï≤´ Î≤àÏß∏ ÎπÑÍµê
        if [ $((idx + 1)) -lt ${#RAW_TAGS[@]} ]; then
            next_tag="${RAW_TAGS[$((idx + 1))]}"
            first=$(printf '%s\n%s\n' "$tag" "$next_tag" | sort -V | head -n1)
            if ! [[ "$first" == "$tag" ]]; then
                echo -e "\nError: Tags are NOT in ASC order: $tag > $next_tag" >&2
                exit 1
            fi
        fi
    done
fi

# 1. ÌòÑÏû¨ Î≤ÑÏ†Ñ Ïù¥ÌõÑÎßå ÌïÑÌÑ∞ÎßÅ
UPDATABLE_TAGS=()

count=1
for idx in "${!ALL_TAGS[@]}"; do
    tag="${ALL_TAGS[$idx]}"
    draw_progress $count ${#ALL_TAGS[@]} "Listing tags after $CURRENT_VERSION" 'Item'

    # ÌòÑÏû¨ Î≤ÑÏ†ÑÎ≥¥Îã§ ÏµúÏã†Ïù¥Î©¥ Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
    if [[ "$(printf '%s\n%s\n' "$CURRENT_VERSION" "$tag" | sort -V | head -n1)" != "$tag" ]]; then
        UPDATABLE_TAGS+=("$tag")
    fi
    count=$((count + 1))
done

if [ -n "$target_version_tag" ]; then
    TEMP=()
    count=1
    for idx in "${!UPDATABLE_TAGS[@]}"; do
        tag="${UPDATABLE_TAGS[$idx]}"
        draw_progress $count ${#UPDATABLE_TAGS[@]} "Listing tags before $target_version_tag" 'Item'

        # ÎåÄÏÉÅ Î≤ÑÏ†ÑÎ≥¥Îã§ ÏµúÏã†Ïù¥Î©¥ Î∞∞Ïó¥Ïóê ÎØ∏Ìè¨Ìï®
        if [[ "$(printf '%s\n%s\n' "$tag" "$target_version_tag" | sort -V | head -n1)" == "$tag" ]]; then
            TEMP+=("$tag")
        fi
        count=$((count + 1))
    done

    UPDATABLE_TAGS=("${TEMP[@]}")
fi

# 2. ÎßàÏù¥ÎÑà Î¶¥Î¶¨Ï¶àÎ≥Ñ Ï≤´/ÏµúÏã† Î≤ÑÏ†Ñ ÏÑ†ÌÉù
declare -A MINOR_FIRST
declare -A MINOR_LATEST
count=1
for idx in "${!UPDATABLE_TAGS[@]}"; do
    tag="${UPDATABLE_TAGS[$idx]}"
    minor=$(echo "$tag" | cut -d. -f1,2)
    draw_progress $count ${#UPDATABLE_TAGS[@]} "Creating Upgrade Path" 'Item'
    # Ï≤´ Î≤àÏß∏ Î∞úÍ≤¨ Ïãú Ï†ÄÏû•
    if [[ -z "${MINOR_FIRST[$minor]}" ]]; then
        MINOR_FIRST[$minor]="$tag"
    fi
    # ÏµúÏã† Î≤ÑÏ†Ñ ÎπÑÍµê
    if [[ -z "${MINOR_LATEST[$minor]}" ]] || [[ "$(printf '%s\n%s\n' "${MINOR_LATEST[$minor]}" "$tag" | sort -V | tail -n1)" == "$tag" ]]; then
        MINOR_LATEST[$minor]="$tag"
    fi
    count=$((count + 1))
done

# Í≤∞Í≥º ÌôïÏù∏
mapfile -t UPGRADE_POINTS_ARRAY < <(
    for minor in $(printf '%s\n' "${!MINOR_FIRST[@]}" | sort -V); do
        echo "${MINOR_FIRST[$minor]}"
        if [[ "${MINOR_FIRST[$minor]}" != "${MINOR_LATEST[$minor]}" ]]; then
            echo "${MINOR_LATEST[$minor]}"
        fi
    done
)

if [ -z "$TARGET_URL" ]; then
    echo 'TARGET_URL is not configured yet. Please enter your GitLab server URL.'
    echo 'e.g.: https://gitlab.com'
    echo -n '> '
    read TARGET_URL
    if [ -z "$TARGET_URL" ]; then
        echo 'User abort'
        exit 1
    fi
fi

if [ ${#UPGRADE_POINTS_ARRAY[@]} -eq 0 ]; then
    echo "Requirements already satisfied: v$CURRENT_VERSION"

    if ! curl -sf -o /dev/null $TARGET_URL/explore/projects; then
        echo "NOTE: If your GitLab server does not work properly, please edit $(docker inspect $CONTAINER_NAME --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}' | tr ' ' '\n' | grep /etc/gitlab | awk -F ':' '{ print $1 }')/gitlab.rb file or 'docker exec -it $CONTAINER_NAME /bin/bash && vi /etc/gitlab/gitlab.rb'"
    fi
    exit 0
fi

echo -e "\nWould you like to upgrade GitLab server from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}?"
echo "This action cannot be undone. PLEASE BACKUP GitLab drive BEFORE STARTING UPDATE..."
echo "You should update pointing releases too. ROUTING COUNT: ${#UPGRADE_POINTS_ARRAY[@]}"
if [ ${#UPGRADE_POINTS_ARRAY[@]} -lt 10 ]; then
    for idx in "${!UPGRADE_POINTS_ARRAY[@]}"; do
        echo -e "\t$((idx + 1)). ${UPGRADE_POINTS_ARRAY[$idx]}"
    done
fi
if [ ${#UPGRADE_POINTS_ARRAY[@]} -le 5 ]; then
    echo -e "\ttraceroute: ${UPGRADE_POINTS_ARRAY[*]}"
fi
if [ $use_all_tags -eq 0 ]; then
    echo "Follow this link to get more information: https://gitlab-com.gitlab.io/support/toolbox/upgrade-path/?current=${CURRENT_VERSION/-ce.0/}&target=${UPGRADE_POINTS_ARRAY[-1]/-ce.0/}&distro=docker"
fi
echo ''
echo -e "\t- I understood that this action DOES NOT SUPPORT rollback"
echo -e "\t- I understood that this action may take a long time due to the ROUTING COUNT."
echo -e "\t- I checked container restart policy: $(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' $CONTAINER_NAME)"
echo -e "\t- I checked container PORTS: $(docker inspect $CONTAINER_NAME --format='{{range $p, $conf := .NetworkSettings.Ports}}{{$p}} -> {{(index $conf 0).HostPort}} {{end}}')"
echo -e "\t- I checked container DRIVE: $(docker inspect $CONTAINER_NAME --format='{{range .Mounts}}{{.Source}}:{{.Destination}} {{end}}')"
echo -e "\t- I checked gitlab external_url in gitlab.rb file: $(docker exec $CONTAINER_NAME grep '^external_url' /etc/gitlab/gitlab.rb | awk -F"'" '{print $2}')"
echo -e "\t- I checked gitlab backup_path in gitlab.rb file: $(docker exec $CONTAINER_NAME grep "'backup_path'" /etc/gitlab/gitlab.rb | awk -F"=" '{print $2}' | sed 's/\"//g' | sed 's/^ //')"
if [ "$(docker exec $CONTAINER_NAME gitlab-psql -tAc "SELECT COUNT(*) FROM ci_runners;")" -eq 0 ]; then
    echo -e "\t- I checked this GitLab server has not configured any runners yet."
else
    echo ''
    echo -e "\t- I checked this GitLab server is configured with the following runners:"
    docker exec $CONTAINER_NAME gitlab-psql -c "SELECT id, description, contacted_at, active FROM ci_runners ORDER BY id;"
    echo ''
fi
if [ $use_all_tags -eq 0 ]; then
    echo -e "\t- I checked TARGET_URL is valid: $TARGET_URL"
else
    echo -e "\t- I checked PAGE_SIZE and TARGET_URL values: PAGE_SIZE: $PAGE_SIZE, TARGET_URL: $TARGET_URL"
fi

echo -en "\nI accept the above notice and continue this job (y/N) > "
read n
if [ "$n" != "y" ] && [ "$n" != "Y" ]; then
    echo 'User abort' >&2
    exit 1
fi

send_discord_webhook "NOTE" "Updating GitLab now!" "GitLab will be upgraded from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}"
auto_restart_enabled=$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' $CONTAINER_NAME)

if ! [ -r /tmp/upgrade-gitlab-ce.lock ]; then
    echo "Creating backups for $CURRENT_VERSION. Please wait until backup process is completed..."
    docker exec $CONTAINER_NAME gitlab-backup create
    BACKUP_DIR=$(docker exec $CONTAINER_NAME grep "'backup_path'" /etc/gitlab/gitlab.rb | awk -F"=" '{ print $2 }' | sed 's/\"//g' | sed 's/^ //')
    docker exec $CONTAINER_NAME sh -c "cp /etc/gitlab/gitlab-secrets.json $BACKUP_DIR/gitlab-secrets.json.${CURRENT_VERSION}-backup"
    docker exec $CONTAINER_NAME sh -c "cp /etc/gitlab/gitlab.rb $BACKUP_DIR/gitlab.rb.${CURRENT_VERSION}-backup"
fi

index=1
CNT_VERSION=$CURRENT_VERSION
for ver in "${UPGRADE_POINTS_ARRAY[@]}"; do
    send_discord_webhook "INFO" "GitLab server is upgrading now! ($index/${#UPGRADE_POINTS_ARRAY[@]})" "Please wait until upgrading process is done."
    echo "Updating $CNT_VERSION to $ver... ($index/${#UPGRADE_POINTS_ARRAY[@]})"
    if ! docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        docker start $CONTAINER_NAME &> /dev/null
        echo -n "waiting until gitlab/gitlab-ce:$CNT_VERSION container is ready..."
        spinner='/-\|'
        n=${#spinner}
        echo -n ' '
        while [ "$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_NAME | grep -v unhealthy | grep -c healthy)" -ne 1 ]; do
            printf '\b%s' "${spinner:i++%n:1}"
            print_stacktrace_errors
            sleep 1
        done
        printf '\b\b%s' " "
        echo 'done'
    fi

    check_gitlab_server_healthy

    if docker ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        echo -n "stopping $CNT_VERSION container with SIGINT signal..."
        docker stop $CONTAINER_NAME &> /dev/null
        echo ' done'
    fi
    echo -n "removing $CNT_VERSION container..."
    docker container rm $CONTAINER_NAME &> /dev/null
    echo ' done'

    echo -n "removing previous $CNT_VERSION image..."
    docker image rm "$(docker images --format "{{.ID}}" gitlab/gitlab-ce)" &> /dev/null
    echo ' done'

    docker pull gitlab/gitlab-ce:$ver
    docker run -d --name $CONTAINER_NAME $VOLUMES $PORTS gitlab/gitlab-ce:$ver

    echo -n "waiting until gitlab/gitlab-ce:$ver server boots... "
    spinner='/-\|'
    n=${#spinner}
    echo -n ' '
    while [ "$(curl -sf -o /dev/null $TARGET_URL/explore/projects -w "%{http_code}\n")" != '200' ]; do
        printf '\b%s' "${spinner:i++%n:1}"
        print_stacktrace_errors $ver $CNT_VERSION
        sleep 1
    done
    printf '\b\b%s' " "
    echo 'done'

    echo -n "waiting until gitlab/gitlab-ce:$ver container is ready... "
    spinner='/-\|'
    n=${#spinner}
    echo -n ' '
    while [ "$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_NAME | grep -v unhealthy | grep -c healthy)" -ne 1 ]; do
        printf '\b%s' "${spinner:i++%n:1}"
        print_stacktrace_errors $ver $CNT_VERSION
        sleep 1
    done
    printf '\b\b%s' " "
    echo 'done'

    if [ $index -lt ${#UPGRADE_POINTS_ARRAY[@]} ]; then
        echo "gitlab-ce $ver update completed. remaining jobs: $((${#UPGRADE_POINTS_ARRAY[@]} - index))"
    else
        echo "gitlab-ce $ver update completed."
        send_discord_webhook "NOTE" "Upgrade process now completed!" "Please wait until GitLab server is ready."
    fi
    CNT_VERSION=$ver
    index=$((index + 1))
done

check_gitlab_server_healthy

if [ "$auto_restart_enabled" == "$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' $CONTAINER_NAME)" ] && [ "$auto_restart_enabled" == 'no' ]; then
    echo "Would you like to change RestartPolicy from $auto_restart_enabled to always?"
    echo 'AVAILABLE OPTIONS'
    echo -e 'no\t\t\t\tDo not automatically restart the container. (Default, Current)'
    echo -e 'on-failure[:max-retries]\tRestart the container if it exits due to an error, which manifests as a non-zero exit code.'
    echo -e 'always\t\t\t\tAlways restart the container if it stops. If it is manually stopped, it is restarted only when Docker daemon restarts or the container itself is manually restarted.'
    echo -e 'unless-stopped\t\t\tSimilar to always, except that when the container is stopped (manually or otherwise), it is not restarted even after Docker daemon restarts.'
    echo -n '> '
    read n
    case "$n" in
        no|always|unless-stopped|on-failure|on-failure:[0-9]*)
            docker update --restart=$n $CONTAINER_NAME
            ;;
        *)
            echo 'If you want to edit RestartPolicy value later, please run `docker update --restart=<rule> <container-name>` to apply.'
            ;;
    esac
elif [ "$auto_restart_enabled" != "$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' $CONTAINER_NAME)" ]; then
    echo "Updating gitlab RestartPolicy from $(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' $CONTAINER_NAME) to $auto_restart_enabled"
    docker update --restart=$auto_restart_enabled $CONTAINER_NAME &> /dev/null
fi

echo "Successfully updated GitLab server from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}"
echo "Updated traceroute: ${UPGRADE_POINTS_ARRAY[*]}"
send_discord_webhook "NOTE" "Successfully upgraded GitLab server!" "GitLab version changed from $CURRENT_VERSION to ${UPGRADE_POINTS_ARRAY[-1]}"
rm /tmp/upgrade-gitlab-ce.lock &> /dev/null

exit 0
